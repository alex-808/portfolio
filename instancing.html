<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js physics - ammo.js instancing</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> physics - ammo.js instancing
		</div>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.5/dat.gui.min.js"></script>
		<script src="./three/examples/js/libs/ammo.wasm.js"></script>
		<script>
			var vertexShader = `
			  varying vec3 vPos;
			  void main()	{
				vPos = position;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
			  }
			`;
			var fragmentShader = `
		  
			  varying vec3 vPos;
			  uniform vec3 size;
			  uniform float thickness;
			  uniform float smoothness;
			 
			  void main() {
					  
				float a = smoothstep(thickness, thickness + smoothness, length(abs(vPos.xy) - size.xy));
				a *= smoothstep(thickness, thickness + smoothness, length(abs(vPos.yz) - size.yz));
				a *= smoothstep(thickness, thickness + smoothness, length(abs(vPos.xz) - size.xz));
				
				vec3 c = mix(vec3(0), vec3(1), a);
				
				gl_FragColor = vec4(c, 1.0);
			  }
			`;
		  
		</script>
		<script type="module">

			import * as THREE from './three/build/three.module.js';
			import { OrbitControls } from './three/examples/jsm/controls/OrbitControls.js';
			import { AmmoPhysics } from './three/examples/jsm/physics/AmmoPhysics.js';
			import Stats from './three/examples/jsm/libs/stats.module.js';

			let camera, scene, renderer, stats;
			let physics, position;

			let boxes, spheres, wireFrames;

			var boxCount = 180
			let flowControlPositions

			let liftIndex = 0
			init();

			async function init() {

				physics = await AmmoPhysics();
				position = new THREE.Vector3();

				// Camera

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 0, 4.5, 0 );
				camera.rotation.x = 1.2
				camera.rotation.y = 1.8
				camera.rotation.z = -1
				// camera.lookAt( 1.5, 4.5, 1 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 'white' );

				// Lights

				const hemiLight = new THREE.HemisphereLight();
				hemiLight.intensity = 0.35;
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight();
				dirLight.position.set( 5, 5, 5 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.zoom = 2;
				scene.add( dirLight );

				// Floor

				const floor = new THREE.Mesh(
					new THREE.BoxBufferGeometry( 10, 5, 10 ),
					// new THREE.ShadowMaterial( { color: 'blue' } )
					new THREE.MeshBasicMaterial({ color: 'white' } )
				);
				floor.position.y = - 10.5;
				floor.receiveShadow = true;
				scene.add( floor );
				physics.addMesh( floor );

				// Flow Control Object
				const flowControl = new THREE.Mesh(
					new THREE.BoxBufferGeometry( 5, .5, 5 ),
					// new THREE.ShadowMaterial( { color: 'blue' } )
					new THREE.MeshBasicMaterial({ color: 'blue' } )
				);
				flowControlPositions = {
					xRotation : 9.7,
					yRotation : 0,
					zRotation : 8.5,
					xPosition : 0,
					yPosition : 4,
					zPosition : -2,
				}

				flowControl.rotation.x = flowControlPositions.xRotation
				flowControl.rotation.z = flowControlPositions.zRotation
				flowControl.position.y = flowControlPositions.yPosition;
				flowControl.position.x = flowControlPositions.xPosition;
				flowControl.position.z = flowControlPositions.zPosition;
				flowControl.receiveShadow = true;
				scene.add( flowControl );
				physics.addMesh( flowControl );

				const flowControl2 = new THREE.Mesh(
					new THREE.BoxBufferGeometry( 5, .5, 5 ),
					// new THREE.ShadowMaterial( { color: 'blue' } )
					new THREE.MeshBasicMaterial({ color: 'blue' } )
				);
				flowControl2.rotation.x = flowControlPositions.xRotation
				flowControl2.rotation.z = -(flowControlPositions.zRotation)
				flowControl2.position.y = flowControlPositions.yPosition;
				flowControl2.position.x = flowControlPositions.xPosition;
				flowControl2.position.z = flowControlPositions.zPosition;
				flowControl2.receiveShadow = true;
				scene.add( flowControl2 );
				physics.addMesh( flowControl2 );
				// Object Material

				const geometryBox = new THREE.BoxBufferGeometry( .1, .1, .1 );

				var material = new THREE.ShaderMaterial({
				uniforms: {
					size: {
					value: new THREE.Vector3(geometryBox.parameters.width, geometryBox.parameters.height, geometryBox.parameters.depth).multiplyScalar(0.5)
					},
					thickness: {
						value: 0.001
					},
					smoothness: {
						value: 0.001
					}
				},
				vertexShader: vertexShader,
				fragmentShader: fragmentShader
				});
				// const material = new THREE.MeshLambertMaterial();

				// const material = new THREE.ShaderMaterial();
				const matrix = new THREE.Matrix4();
				const color = new THREE.Color();

				// Wireframe Material

				const wireFrameMaterial = new THREE.LineBasicMaterial({color: 'black'})

				// Boxes
				// var box = new THREE.Mesh( geometryBox, material );
				// scene.add( box );
				// const geometryWireFrame = new THREE.EdgesGeometry( geometryBox )
				// wireFrames = new THREE.LineSegments(geometryWireFrame, wireFrameMaterial, 10)
				// boxes = new THREE.InstancedMesh( geometryBox, material, 100 );
				// var box2 = new THREE.Mesh(geometryBox, material)
				boxes = []

				for (let i = 0; i < boxCount; i++) {

					var box = new THREE.Mesh(geometryBox, material)
					console.log('this')
					scene.add( box );
					boxes.push(box)
					physics.addMesh( box, 10 );
					box.castShadow = true;
					box.receiveShadow = true;
				}

				// boxes.castShadow = true;
				// boxes.receiveShadow = true;
				// scene.add( boxes );
				// scene.add( wireFrames )
				// console.log(boxes)
				// for ( let i = 0; i < boxes.count; i ++ ) {
					// Sets initial loading position of boxes
					// matrix.setPosition( Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5 );
					// boxes.setMatrixAt( i, matrix );
					// boxes.setColorAt( i, color.setHex( 0xffffff ) );

				// }

				
				// physics.addMesh(wireFrames, .1)
				// physics.addMesh( boxes, .1 );
				// physics.addMesh( box, .1 );

				// Wireframe
				var gui = new dat.GUI();
				const cameraFolder = gui.addFolder("Camera")
				cameraFolder.add(camera.position, "y", 0, 10).name("camera y");
				cameraFolder.add(camera.position, "x", 0, 10).name("camera x");
				cameraFolder.add(camera.position, "z", 0, 10).name("camera z");
				cameraFolder.add(camera.rotation, "y", -4, 4).name("rotation y");
				cameraFolder.add(camera.rotation, "x", -4, 4).name("rotation x");
				cameraFolder.add(camera.rotation, "z", -4, 4).name("rotation z");

				const boxLinesFolder = gui.addFolder("BoxLines")
				boxLinesFolder.add(material.uniforms.thickness, "value", 0.001, .01).name("thickness");
				boxLinesFolder.add(material.uniforms.smoothness, "value", 0.001, .01).name("smoothness");
				
				const flowControlFolder = gui.addFolder("FlowControl")

				flowControlFolder.add(flowControl.position, "x", 0, 10).name("flowControl x");
				flowControlFolder.add(flowControl.position, "z", 0, 10).name("flowControl z");
				flowControlFolder.add(flowControl.rotation, "y", 0, 10).name("fc rotation y");
				flowControlFolder.add(flowControl.rotation, "x", 8, 11).name("fc rotation x");
				flowControlFolder.add(flowControl.rotation, "z", 0, 10).name("fc rotation z");

				
				flowControlFolder.add(flowControl2.position, "x", 0, 10).name("flowControl2 x");
				flowControlFolder.add(flowControl2.position, "z", 0, 10).name("flowControl2 z");
				flowControlFolder.add(flowControl2.rotation, "y", 0, 10).name("fc2 rotation y");
				flowControlFolder.add(flowControl2.rotation, "x", 8, 11).name("fc2 rotation x");
				flowControlFolder.add(flowControl2.rotation, "z", 0, 10).name("fc2 rotation z");

				// Renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.outputEncoding = THREE.sRGBEncoding;
				document.body.appendChild( renderer.domElement );
				renderer.setClearColor(0x404040);
				stats = new Stats();
				document.body.appendChild( stats.dom );

				// Renderer

				const controls = new OrbitControls( camera, renderer.domElement );
				// controls.target.y = 0;
				// controls.target.x = 0;
				// controls.target.z = 0;
				controls.update();

				animate();

			}
			
			function animate() {

				requestAnimationFrame( animate );
				
				if (liftIndex === boxCount) {
					liftIndex = 0
				}
				else {
					liftIndex++
				}
				
				for (let i = 0; i < 2; i++) {
					// Picks a random box
					// index = Math.floor( Math.random() * boxCount );
					// Randomly sets a new position at top
					// boxes[index].position.x = ( Math.random() + 10 )
					position.set( Math.random() - .5, Math.random() + 6, Math.random() - .5);
					physics.setMeshPosition(boxes[liftIndex], position)

					// boxes.setColorAt( index, color.setHex( 'blue' * Math.random() ) );
					// moves mesh to that position
					// physics.setMeshPosition( boxes, position, index );



				}


				//

				// index = Math.floor( Math.random() * spheres.count );

				// position.set( 0, Math.random() + 1, 0 );
				// // physics.setMeshPosition( spheres, position, index );

				renderer.render( scene, camera );

				stats.update();

			}

		</script>
	</body>
</html>